[
  {
    "id": 0,
    "title": "A fresh start",
    "category": "stuff",
    "tags": [
      "blog"
    ],
    "url": "/blog/2014/02/06/A-fresh-start/",
    "content": "2014 has just started a month ago and I've painfully realized that I\ndidn't come up with any New Year's resolutions at that time. There is\nno resolution to violate, consequently, no reason to feel bad at all -\nso why not start a new blog which I could then feel bad about when I\npost nothing for months?! Well, to be serious, that's at least how all\nmy blogging attempts have ended so far. I definitely don't know if\nhistory will repeat itself again this time. Maybe this post will actually stay the\nonly post for two months? Any bets? ;-)\n\nAnyway, I better shortly summarize what I plan blogging about. Being a\nsoftware developer, tech topics will probably dominate. Still I can't\npromise not to rant about some random topic from time to time ;-) As\nan Emacs user I might blog about my **Elisp** learning progress or other\nstuff like the one and only **org-mode**. Using **Octopress** as my blogging\nengine it will be unavoidable to mention it as well, ranging from\nplugins and customizations to its philosophy. From time to time I'd also\nlike talking about my journeys to **Haskell** wonderland and\n**Clojure(Script)** development. Or mention some Android apps? There are\nenough topics for sure, we'll see if there is enough motivation to\ncarry on blogging as well ;-)\n\nLet's hope the best!\n",
    "date": {
      "year": "2014",
      "month": "February",
      "day": "06"
    }
  },
  {
    "id": 1,
    "title": "Why Blogging Matters",
    "category": "stuff",
    "tags": [
      "blog"
    ],
    "url": "/blog/2014/02/07/Why-Blogging-Matters/",
    "content": "There is that fancy phrase \"pics or it didn't happen\". It's just\nclaiming evidence for a, more or less, hardly credible experience which has often to do\nwith some sort of drug abuse. Yes, experience shows it's\nsometimes cleverer to do without taking a photo, anyway, it crossed my mind that that phrase might be\napplicable not only to excess-like experiences but to&#x2026; pretty much\neverything in life.\n\n<!-- more -->\n\nI'll come back later to what that actually means.. actually, I've just found a nice <a href=\"http://mdswanson.com/blog/2013/08/11/write-things-tell-people.html\" target=\"_blank\">blog post</a>\nabout the importance of running a blog as a developer which goes\nnicely with what I've been thinking. The author, Matt Swanson, says\n\"Do things, write about it\" and explains how sharing his learning on\nhis blog has been incredibly rewarding: Firstly, people told him how much they\nenjoy reading his posts (those compliments alone may be worth it!) and secondly, he gained reputation by\ndemonstrating his abilities and initiative. As a result, he somehow became some\nsort of a \"super hero\" in people's minds although his posts are not\nexactly rocket-science. Regular posts (content is still king!) and a\npretty straight-forward way of expressing things were enough to raise\nhis value&#x2026; the question is: Did Matt just fool his readers? Isn't he a clever guy after all? \n\nOf course he is \"clever\". He is \"clever\" **because** he shares his\nprojects, learnings and insights on his blog. Being a Software\ndeveloper, blogging about your projects is the most efficient way of\ngaining an over-all reputation - a manager, who considers hiring you, won't read commit logs of Open Source\nProjects where your name might appear but he can enjoy a well-written blog! In fact,\nthe 'positive' effect on the manager's decision seems inevitable; and that's\nwhere the \"pics or it didn't happen\" attitude comes into play. In\norder to convey your abilities to the manager you need definite proof,\npretty similiar to the situation in court, actually: In the end, the\njudge reaches a verdict and **decides what is the truth**. Analogously,\nyou will always **be** exactly as \"clever\" as your vis-Ã -vis, respectively the\nreaders of your blog, think you are! It goes without saying that you\ncan replace the word \"clever\" with whatever other positive quality you'd\nlike to convey - \"competent\", \"open-minded\", \"innovative\", &#x2026;, you\nname it.\n\nFunnily enough, you will actually get cleverer when you blog regularly\n;-) Strange? Well, first let's get rid of the word \"clever\" once and\nfor all, it is somehow inaccurate - what I want to say is: You will\nget better at those topics you're blogging about. (And that not only\napplies to tech blogs!) The reason for that: The extra thinking\nnecessary for presenting your work in a nicely structured way on your\nblog will actually force you to nicely structure your projects as\nwell! In addition, your inner urge to at least blog once, twice or X\ntimes a week will actually force you to pursue your projects and\nlearnings 'cause otherwise you wouldn't have anything to blog about.\nAs a result, you'll inevitably get better at reasoning and get a\nbetter understanding of your blog posts' topics&#x2026; briefly, you get\n\"cleverer\"! Isn't that ironic? ;-) \n\nAnyway, I haven't been able to post regularly in the past, for\nwhatever reasons. In the end that always led to abandonning my past blogs altogether, so I'm not\nquite sure the above argumentation is too believable coming from me,\nto be honest. However, for the moment, it is enough motivation for me to try a fresh\nstart with this blog. After all, it's all about motivation and inspiration.\n",
    "date": {
      "year": "2014",
      "month": "February",
      "day": "07"
    }
  },
  {
    "id": 2,
    "title": "Book Catalogue",
    "category": "tech",
    "tags": [
      "android",
      "app",
      "book"
    ],
    "url": "/blog/2014/02/10/Book-Catalogue/",
    "content": "{% img left /images/book-catalogue.png 200px  %}\n\nA week ago I've downloaded the app\n<a href=\"https://play.google.com/store/apps/details?id=com.eleybourn.bookcatalogue&hl=de\" target=\"_blank\">Book Catalogue</a> from the Android Play store. As its name suggests it's\nabout creating a catalogue of your books. My family and I thought it would be handy\nto file our books as we easily lose track of what books we actually own\nand where we have stored them.\n\n**Book Catalogue** makes it all possible: adding books by scanning the\nbarcode, by ISBN, by searching author/title or by adding all\ninformation manually. Of course, every book is stored to be in exactly\none bookshelf - you can create as many bookshelves as necessary and\ncan name them as you want.\n\n<!-- more -->\n\nIn addition, **Book Catalogue** provides syncing to a <a href=\"http://www.goodreads.com/\" target=\"_blank\">GoodReads</a> account.\nI was really looking forward to this as it would make sharing the\ndigital library with my family extremely easy&#x2026; but only in theory.\nIt turned out that the GoodReads API only allows books to be added if\nthe book already exists on GoodReads. Anyway, the app makes a good\njob to actually inform you which books couldn't be uploaded\nsuccessfully. You could then add those books on the GoodReads web\nsite, however, it's very cumbersome to do that for all missing books;\nso far, I have filed a few hundred books and about a fifth of them\nGoodReads does not know. So the GoodReads sync option is not *really*\nusable after all (especially if you have many old or rare books as\nthey are then likely to be unknown to GoodReads). Luckily, a CSV\nimport/export is provided as well so that I'm not entirely dependent on\nGoodReads's good will ;-)\n\nStill, **Book Catalogue** really is a great app in my opinion (the imperfect GoodReads\nAPI is not the app's fault). Firstly, it's interface is really beautiful and\nprovides nice ways to list the books in various ways. More\nimportantly, the identification of books by barcode and ISBN really\nworks well, including the downloading of meta information from several\nsources like Amazon, LibraryThing, GoodReads and Google Books in\na blink!\n\nWell, it needs to be mentioned that **Book Catalogue** is an Open Source\nproject and <a href=\"https://github.com/eleybourn/Book-Catalogue\" target=\"_blank\">can be found on GitHub</a>. So I might actually implement a\nworking syncing option when I'm really convinced it's worth the work.\nUntil then I'll keep fiddling with CSV export files to keep\neverybody's installation up-to-date on our shared library. It's not\nperfect but it works&#x2026;\n",
    "date": {
      "year": "2014",
      "month": "February",
      "day": "10"
    }
  },
  {
    "id": 3,
    "title": "Explaining Haskell RankNTypes for all",
    "category": "programming",
    "tags": [
      "extension",
      "ghc",
      "haskell",
      "rankntypes"
    ],
    "url": "/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/",
    "content": "The Glasgow Haskell Compiler supports a language extension called\n`RankNTypes` which I've had my problems to understand. The moment I\nunderstood that it mostly refers to first-order logic universal\nquantification things became easier, though&#x2026; but first let's explore why we\nneed it in a step-by-step example.\n\n<!-- more -->\n\n## length :: forall a. [a] -> Int\n``` haskell\n:t length\n-- length :: [a] -> Int\nlength [1,2,3]\n-- 3\nlet intLength :: [Int] -> Int; intLength = length\n:t intLength\n-- intLength :: [Int] -> Int\nintLength [1,2,3]\n-- 3\n```\n\nWe start with the well-known polymorphic function `length` in a fresh\nGHCI session. Above we\nsee how the type checker instantiates `a` to be `Int` in the type of\n`intLength`. Likewise we could create a function `charLength` -\nanyway, `length` can be instantiated to oblige to a list of any type\nwe want, so it is defined *for all* possible types `a`. For the sake\nof simplicity, I'll call a function like `intLength` (which actually\ncorresponds to instantiating the type variable `a` of `length`) a\n*version* of `length`.\n\nAs a matter of fact, a normal Haskell type signature such as `[a]\n-> Int` always implies that the type variable(s) are universally\nquantified with 1 *forall* section located at the beginning of the\ntype declaration. `length`'s type thus corresponds to `forall a. [a] ->\nInt`. We call such a type a *Rank-1-Type* as there is 1 *forall* in\nthe type annotation. The fact that we can omit the *forall* usually -\nand aren't used to it as a consequence - will make things look complicated\nwhen we actually need it, as we'll see later on. In the end, *forall* provides\na scope just like its first-order logic equivalent.\n\n## Apply a length-like function to a list\n``` haskell\nlet apply :: ([a] -> Int) -> [a] -> Int; apply f x = f x\napply length \"hello world\"\n-- 11\napply intLength [1,2,3]\n-- 3\n```\n\nThe `apply` function just applies a function that takes a list and\nreturns an `Int` (like `length` does) to a value.\nNothing fancy nor useful at all, obviously. Still, let's note that under the hood\nthe type of `apply` is `forall a. ([a] -> Int) -> [a] -> Int`. So far, so\ngood, the type checker is happy. Now let's a write a function\n`applyToTuple` that applies a function like `length` to a tuple of\nlists so that the lists of the tuple can be of different types.\n\n## Apply a length-like function to a tuple of lists\n``` haskell\nlet applyToTuple f (a@(x:xs),b@(y:ys)) = (f a, f b) :: (Int, Int)\napplyToTuple length (\"hallo\",[1,2,3])\n--No instance for (Num Char)\n--  arising from the literal `1'\n-- ...\n:t applyToTuple\n-- applyToTuple :: ([t] -> Int) -> ([t], [t]) -> (Int, Int)\n```\n\nI wrote `applyToTuple` without a full type signature. `:: (Int,Int)`\njust makes sure my wanted result type and by the help of the list\ndestructuring `a@(x:xs)` I make sure that the type inference algorithm\nwill conclude \nthat I have a tuple of lists in mind. Consequently, the type of the\nfunction given to `applyToTuple` is inferred to correspond to\n`length`'s type; at least, that's what I would expect naively.\n\nHowever, type inference of `applyToTuple` does not result in the type I had\nin mind. As we can see the types of lists in the tuple `([t],[t])` are\nthe same so that calling `applyToTuple length` with a heterogeneous\ntuple like `(\"hallo\",[1,2,3])` doesn't work. Being stubborn I could\nthen try \"forcing\" the type by providing a type signature:\n\n``` haskell\nlet applyToTuple :: ([a] -> Int) -> ([b],[c]) -> (Int, Int); applyToTuple f (x,y) = (f x, f y)\n-- Couldn't match type `b' with `a' ...\n-- Couldn't match type `c' with `a' ...\n```\n\nThis attempt also fails as GHCI complains about the fact that the\ntypes `b` and `a`, `c` and `a` respectively, do not match! However, the\n`length`-like function `([a] -> Int)` should be applicable to a list of\nwhatever type, shouldn't it?!? That's the moment\nyou'd start doubting either GHCI or your mental health as you know precisely\nthat it *should be possible* to write such a function. After all, you\nknow intuitively that it **is** possible to apply a function like `length`\nto both parts of a heterogeneous tuple of lists as in the code below;\ndoing that in a more generic way in a function like `applyToTuple`\nshould be possible as well!\n\n``` haskell\n-- Obviously, that works without a problem:\n(\\(a,b) -> (length a, length b)) (\"hallo\",[1,2,3])\n-- (5,3)\n```\n\n## applyToTuple :: (forall a.[a] -> Int) -> ([b],[c]) -> (Int, Int)\nWell, there is just one explanation: the type `([a] -> Int)\n->([b],[c]) -> (Int, Int)` is not really what we need for our purpose.\nIn fact, we need `RankNTypes`!\nWe first enable the extension in GHCI and can then write the correct\n`applyToTuple` implementation using the `forall` keyword in the type\nof the first parameter function. (If you want to use the\n`RankNTypes` extension in a file to compile, you actually need to add `{-#\nLANGUAGE RankNTypes #-}` at the top of the file)\n\n``` haskell\n:set -XRankNTypes\nlet applyToTuple :: (forall a.[a] -> Int) -> ([b],[c]) -> (Int, Int); applyToTuple f (x,y) = (f x, f y)\napplyToTuple length (\"hello\", [1,2,3])\n-- (5,3)\n```\n\nThis time it works! :-)\n\n## Explanation\nWe noted earlier that every Haskell type signature's type variables\nare *implicitly* universally quantified by an 'invisible' `forall`\nsection. Thus, under the hood we get the types as follows:\n\n``` haskell\n-- just a reminder:\n-- length :: forall a. [a] -> Int \nlet intLength :: [Int] -> Int; intLength = length \n\n--  applyToTuple:\nlet applyToTuple :: forall a b c. ([a] -> Int) -> ([b], [c]) -> (Int, Int); applyToTuple f (x,y) = (f x, f y) \n-- correct applyToTuple:\nlet applyToTuple :: forall b c. (forall a. [a] -> Int) -> ([b], [c]) -> (Int, Int); applyToTuple f (x,y) = (f x, f y)\n```\n\nNow things get clearer: The function in the type of the correct\n`applyToTuple` has the type `(forall a. [a] -> Int)` which is exactly\nthe type given for `length` above, hence it works. On the other hand,\nthe type `([a] -> Int)` of the function parameter in the wrong\n`applyToTuple` type signature *looks* like the type of `length` **but it isn't**!\n\nHave a look at what the type\nchecker would \"think\" confronted with the wrong `applyToTuple` type\nsignature. When it reads the expression `applyToTuple length` it would\nexpect the type variables `a`, `b` and `c` to be **different**\nconcrete types, so `([a] -> Int)` might become `([Char] -> Int)` or\n`([Int] -> Int)` like our `intLength` function, shortly, some\n*version* of `length`. In the implementation `(f x, f y)` seeks to apply that *version* of\n`length` to two lists of **different** types - however, **any** *version* of\n`length` expects its list to always be of 1 concrete type only, e.g. `Int` in\nthe case of our function `intLength`, consequently, the type checker\nrefuses the lists of the tuple to possibly be of different types!\n\nWhy does the correct definition of `applyToTuple` work then? It\nexpects a `length`-like function of type `(forall a. [a] -> Int)`, that's a function\nwhich works **for all** types `a`, no matter what type you throw at it!\nThus, it forces that function to be a polymorphic function just like\n`length` and rules out any candidate *version* of `length` (like `intLength`) as a consequence.\nSince you can throw a list of any type at that function it can deal with the 2\nlists of different types and the code compiles! \n\n## Conclusion\nUsing `RankNTypes` and the *forall* keyword you can specify that a\nfunction's argument needs to be a *polymorphic* function (like\n`length` in our example). In spite of the fact that you can omit the top-level\n*forall* in the type signature of a polymorphic type, you need to include\nit when you reference it as a parameter.\n\nIn a future blog post I will investigate an important application of\n`RankNTypes` in the Haskell standard library. It will be about the\n`ST` monad which provides a *safe* environment for **mutation** in\nHaskell with the help of `RankNTypes`. Mutation and Haskell?! Yes,\nyou can do it thanks to `RankNTypes`!\n\n*PS: There is a nice*\n<a href=\"http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do\" target=\"_blank\">stackoverflow thread</a> *which investigates the use of \"forall\" in other\nlanguage extensions as well. Actually, my \"applyToTuple\" function is based on*\n<a href=\"http://stackoverflow.com/a/3071932/928944\" target=\"_blank\">that answer</a> of the thread.\n",
    "date": {
      "year": "2014",
      "month": "February",
      "day": "12"
    }
  }
]