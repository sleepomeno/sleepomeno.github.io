<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | while true live]]></title>
  <link href="http://sleepomeno.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://sleepomeno.github.io/"/>
  <updated>2015-03-15T01:19:13+01:00</updated>
  <id>http://sleepomeno.github.io/</id>
  <author>
    <name><![CDATA[Gregor Riegler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Approximating PI with PureScript]]></title>
    <link href="http://sleepomeno.github.io/blog/2015/03/14/Approximating-PI-with-PureScript/"/>
    <updated>2015-03-14T00:00:00+01:00</updated>
    <id>http://sleepomeno.github.io/blog/2015/03/14/Approximating-PI-with-PureScript</id>
    <content type="html"><![CDATA[<p>Oh, it is Pi day! To be honest, I had not known about it until today
but it somehow made it into my Twitter stream. Well, after some relaxed Saturday morning browsing I stumbled across the <a href="http://demonstrations.wolfram.com/ApproximatingPiWithInscribedPolygons/" target="_blank">Wolfram Pi approximation demonstration</a>. It looks like this:</p>

<script type='text/javascript' src='http://demonstrations.wolfram.com/javascript/embed.js' ></script>


<script type='text/javascript'>var demoObj = new DEMOEMBED(); demoObj.run('ApproximatingPiWithInscribedPolygons', '', '389', '613');</script>


<div id='DEMO_ApproximatingPiWithInscribedPolygons'><a class='demonstrationHyperlink' href='http://demonstrations.wolfram.com/ApproximatingPiWithInscribedPolygons/' target='_blank'>Approximating Pi with Inscribed Polygons</a> from the <a class='demonstrationHyperlink' href='http://demonstrations.wolfram.com/' target='_blank'>Wolfram Demonstrations Project</a> by Rob Morris</div>


<br />


<p>Pi is approximated by computing the area of the inscribed
polygon and by dividing that area by the square of the circle radius &ndash;
after all, the area of a circle is <strong>r²π</strong>. Obviously, that idea is
that beautiful and so simple that Pi has thus been approximated thousands of
years ago (of course, there are many better and faster ways!), so
I decided to implement it myself.</p>

<!-- more -->


<h2>PureScript</h2>

<p>Some days ago I stumbled across <strong>PureScript</strong> which compiles to
JavaScript. It is heavily influenced by Haskell and shares its quality
of static typing. However, it has been designed to target JavaScript
from the getgo such that it incorporates the strict evaluation
semantics of JavaScript. In addition, it provides a syntax similar to
native JavaScript for accessing object properties. Given some Haskell knowledge,
PureScript seems to be a decent alternative to Fay or Haste for
creating Javascript code! So I thought I would give
it a try and implement something similar to the above Wolfram
demonstration! So this is the result I accomplished after one day&rsquo;s
work on a <a href="http://sleepomeno.github.io/pi/html/index.html" target="_blank">PureScript clone</a>:</p>

<iframe src="http://sleepomeno.github.io/pi/html/index.html" width="500" height="700" style="margin:auto;display:block"></iframe>


<h3>PureScript learning resources</h3>

<p>First of all these are the best resources on PureScript development that I found:</p>

<ul><li>

<a href="https://gist.github.com/paf31/8e9177b20ee920480fbc" target="_blank">24 days of PureScript</a>

</li><li>

<a href="https://leanpub.com/purescript" target="_blank">PureScript by Example</a> - very detailed but excellent!

</li><li>

<a href="https://github.com/purescript/purescript/wiki" target="_blank">PureScript Wiki</a> 

</li></ul>


<p><a href="https://gist.github.com/paf31/8e9177b20ee920480fbc" target="_blank">24 days of PureScript</a> gives a very good overview of the PureScript
library landscape. Above all, running code for every introduced
library is given which is crucial to getting quickly started. In
addition, there is a project called <a href="http://pursuit.purescript.org/" target="_blank">Pursuit</a> which provides a search
engine for functions of PureScript packages. It is still far from
being as useful as Hoogle or Hayoo for Haskell development, though.</p>

<h2>PureScript libraries and building process</h2>

<p>PureScript libraries are managed by <strong>bower</strong> which has worked
surprisingly well for me. However, at the beginning I had problems getting the interpreter <code>psci</code> running with
all dependencies as I&rsquo;m not used to <strong>grunt</strong> (and <strong>npm</strong>) which are
typically needed in the whole building process. Anyway, when I decided
to use certain PureScript libraries for my implementation their
integration worked like a charm!</p>

<h2>HTML5 Canvas bindings</h2>

<p>PureScript has very decent wrappers of the HTML5 Canvas API in form
of <code>purescript-canvas</code> and <code>purescript-free-canvas</code>. Obviously, I made
heavy use of those to get the circle and the polygon drawn.</p>

<p><code>haskell
center = { x : 210, y : 210 }
drawCircle = do
  arc { x: center.x, y: center.y, r: radius, start: 0, end: Math.pi * 2 }
  setFillStyle "#000000"
  fill
</code></p>

<p>As an argument to <code>arc</code> we actually have an example of the <em>Object</em>
syntax of PureScript which is just like native JavaScript.</p>

<h2>Angular, React or something else?</h2>

<p>PureScript does have bindings to AngularJS and React (find PureScript
libraries by <a href="http://bower.io/search/?q=purescript" target="_blank">searching bower</a>), however, they are both still
experimental and alpha. So I somehow didn&rsquo;t want to commit to something
half-working which could be very hard to understand for a PureScript
newbie like me. Anyway, I decided that the JQuery binding of
<code>purescript-jquery</code> should be enough for my Pi approximation application; in the end, I
also used <code>purescript-rx</code> (also mentioned on <a href="https://gist.github.com/paf31/8e9177b20ee920480fbc" target="_blank">24 days of PureScript)</a>
but I only scratched the surface of reactive PureScript UI modelling.</p>

<h2>What about the slider?</h2>

<p>I definitely wanted a fancy slider for setting the number of vertices
of the polygon like in the Wolfram demo &ndash; without
too much ado, I immediately decided on using the vanilla <a href="http://jqueryui.com/slider/" target="_blank">JQuery-UI
slider</a>. Copy-Paste. That however means that my PureScript has to
somehow interact with the native slider JavaScript.</p>

<h2>The main function</h2>

<p>The first few lines are about getting representations of the HTML
elements with <code>purescript-jquery</code>. Then I define event handlers for
changing the number of vertices and for toggling the checkbox to
show/hide the triangles. <code>onAsObservable</code> actually is from the
<code>purescript-rx</code> binding to the reactive <a href="https://github.com/Reactive-Extensions/RxJS" target="_blank">RxJS</a> libraries which could be
used to define complex event handling.</p>

<p>``` haskell
main = do
  canvas &lt;&ndash; getCanvasElementById &ldquo;canvas&rdquo;
  context &lt;&ndash; getContext2D canvas
  verticesInput &lt;&ndash; select &ldquo;#vertices&rdquo;
  polygonArea &lt;&ndash; select &ldquo;#polygonArea&rdquo;
  pi &lt;&ndash; select &ldquo;#pi&rdquo;
  triangles &lt;&ndash; select &ldquo;#triangles&rdquo;</p>

<p>  let updateUI num showTriangles = do</p>

<pre><code>  { pArea : polygonAreaPercent, pi : piApprox } &lt;- showPolygon canvas context num showTriangles
  setText (show polygonAreaPercent &lt;&gt; "%") polygonArea
  setText (show piApprox) pi
</code></pre>

<p>  let updateUI' = do</p>

<pre><code>    showTriangles &lt;- ((== "true") &lt;&lt;&lt; stringify) &lt;$&gt; getProp "checked" triangles
    num &lt;- (stringify &gt;&gt;&gt; readInt 10) &lt;$&gt; getValue verticesInput
    updateUI num showTriangles
</code></pre>

<p>  trianglesChange &lt;&ndash; &ldquo;click&rdquo; <code>onAsObservable</code> triangles
  trianglesChange <code>subscribe</code> _ &ndash;> void updateUI'</p>

<p>  verticesChange &lt;&ndash; &ldquo;focus&rdquo; <code>onAsObservable</code> verticesInput
  verticesChange <code>subscribe</code> _ &ndash;> void updateUI'</p>

<p>  updateUI defaultVertices defaultShowTriangles
```</p>

<h2>The Foreign Function Interface</h2>

<p>In the above code I accessed the current value of the checkbox and the
slider value with the <code>purescript-jquery</code> functions <code>getValue</code> and
<code>getProp</code>. However, it was surprisingly difficult to use those values
as they were not of type <code>String</code> but <code>Foreign</code> and I got those
dragged into the field of the Foreign Function Interface for
communicating with JavaScript code. Anyway, after some digging in I
ended up writing the function <code>stringify</code> which trivially transforms the
incoming Javascript value to a <code>String</code>.</p>

<p><code>haskell
foreign import stringify
  "function stringify(x) {\
  \  return x+\"\";\
  \}" :: Foreign -&gt; String
</code></p>

<p>That&rsquo;s an example of how you can integrate JavaScript functions in
PureScript. It is a little bit of a joke as of now sice you need to add all
those backslashes, however, things might get easier in case PureScript
gets a meta programming facility like <strong>TemplateHaskell</strong> in the Haskell
world in the future.</p>

<h2>Conclusion</h2>

<p>All in all, PureScript really makes a nice impression. There is already
a surprising number of libraries available; decent, mature bindings to
Angular or React would be crucial for getting easy web development
adoption, though. Meta programming integration of JavaScript code would
also prove very nice as would be Source Map support&#x2026; anyway, I&rsquo;m
looking forward to using it again and might get into improving it myself.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Partial matching in R]]></title>
    <link href="http://sleepomeno.github.io/blog/2015/02/20/Partial-matching-in-R/"/>
    <updated>2015-02-20T00:00:00+01:00</updated>
    <id>http://sleepomeno.github.io/blog/2015/02/20/Partial-matching-in-R</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve not been too exposed to statistics programming in the last few
year, however, sometimes it couldn&rsquo;t be avoided &ndash; and R couldn&rsquo;t be
avoided! (I still have too much self-esteem to think about
falling back to Excel, even for the simplest things.)</p>

<p>I don&rsquo;t hate R and I don&rsquo;t like R; it just strikes me as very
<strong>strange</strong>. Often, the syntax strikes me as odd and above all, the
multitude of ways to express the same thing reminds of my little Perl
experience. Anyway, I have subscribed to the Coursera R course for fun
and in hope to somehow &ldquo;get the better of R&rdquo;, to grok in on a deep
level or to at least get a more profound idea as to why I don&rsquo;t like it ;)</p>

<p>Anyway, here is a language construct which is very <strong>strange</strong> and a
little bit absurd, no whatever how often I think about it. It&rsquo;s called
<span class="underline">partial matching</span>. To put it bluntly, partial matching makes it
possible to avoid spelling out the whole name of an element of a list
in oder to access it. Let&rsquo;s have a look.</p>

<!-- more -->


<p><code>r
x &lt;- list(a_is_the_first_letter = 1 : 5)
</code></p>

<p>Now let&rsquo;s access <code>a_is_the_first_letter</code>! That&rsquo;s the normal way:</p>

<p>``` r
x$a_is_the_first_letter</p>

<h1>1 2 3 4 5</h1>

<p>```</p>

<p>However, you could make your life a lot &ldquo;easier&rdquo;:</p>

<p>``` r
x$a</p>

<h1>1 2 3 4 5</h1>

<p>```</p>

<p>Well, the crucial question is: what happens if the prefix of your
partial matching is not unique?</p>

<p>``` r
x &lt;&ndash; list(a_is_the_first_letter = 1 : 5,</p>

<pre><code>      a_is_my_first_letter_too = 6 : 10)
</code></pre>

<p>x$a</p>

<h1>NULL</h1>

<p>```</p>

<p>The result is <code>NULL</code>!</p>

<p>``` r
x &lt;&ndash; list(a_is_the_first_letter = 1 : 5,</p>

<pre><code>      a_is_my_first_letter_too = 6 : 10)
</code></pre>

<p>x$a_is_m</p>

<h1>6 7 8 9 10</h1>

<p>```</p>

<p>Here the prefix is unique again. Hooray!</p>

<p>Funny, isn&rsquo;t it? I don&rsquo;t like it, though. Why? Because it&rsquo;s not &lsquo;obvious&rsquo;.
You need to know that feature beforehand, otherwise the fact that an
accidentally misspelled field is handled the same way as a non-unique
field prefix (both returning <code>NULL</code>) is awkward, to say the least.
It&rsquo;s nearly as though I said to the R interpreter: &lsquo;Give me field
xy or any field that is somehow similar&#x2026; or just do what you fucking
want (= return NULL)!&rsquo; Anyway, it introduces complexity and indeterminism into the code.</p>

<p>There is another twist to partial matching. Of course, there is more
than one way to access a field of a list. Making use of the double bracket
syntax, that feature of partial matching is handled differently.</p>

<p>``` r
x &lt;&ndash; list(a_is_the_first_letter = 1 : 5)
x[[&ldquo;a&rdquo;]]</p>

<h1>NULL</h1>

<p>```</p>

<p>Using the double bracket field accessing method, partial matching is
not the default. But R is perly so you still have a way to get that
behavior in a different way:</p>

<p>``` r
x[[&ldquo;a&rdquo;, exact = FALSE]]</p>

<h1>1 2 3 4 5</h1>

<p>```</p>

<p>At least I now have a better idea why I don&rsquo;t really like R. It
introduces a sort of laisser-faire programming which I consider too
&ldquo;inexact&rdquo;. I mean, would you really want something like the following to be the
future of programming:</p>

<p>``` java
interface God {</p>

<pre><code>void killMankind();
void keepUpTheGoodWork();
</code></pre>

<p>}</p>

<p>// &hellip;
god.k() // What the hell happens? Who cares.
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[else return null]]></title>
    <link href="http://sleepomeno.github.io/blog/2015/01/05/else-return-null/"/>
    <updated>2015-01-05T00:00:00+01:00</updated>
    <id>http://sleepomeno.github.io/blog/2015/01/05/else-return-null</id>
    <content type="html"><![CDATA[<p>I guess everybody has a story or two in store about Nullpointer
exceptions in Java (or in any language with nullable values). Sooner or later you will make the acquaintance of the dreaded stacktrace line
denoting that you did something terribly wrong, demanding a value
where none exists, and you just wonder <em>why, how the hell can that
object be null?!</em> during an hour of painful debugging&#x2026; you know
that? Good. Well, I won&rsquo;t ponder over how to avoid it, how to apply
proper error handling etc. (that&rsquo;s way too complicated, I&rsquo;m tired) but I&rsquo;d just like to point out my personal
favourite, the
famous <code>else return null</code> idiom.</p>

<!-- more -->


<p>Anyway, the below snippet shows what I actually mean by that.</p>

<p>``` java
// Version 1
if (password == &ldquo;12345&rdquo;)
   return valuableTreasure;
else
   return null;</p>

<p>// or, equivalently
// Version 2
if (password == &ldquo;12345&rdquo;)
   return valuableTreasure;
return null;
```</p>

<p>To make things more familiar, in Version 2 you could imagine multiple <code>return null</code> lines hidden in
various control structures in an endless method and you surely get an idea
how people feel when they try to reason about an object being <em>null</em>
or not.
Anyway, spotting an <code>else return null</code> I always get a bad gut feeling
saying that things are not what they are supposed to be. I&rsquo;m aware
that this obviously touches upon the question if you should avoid
<em>null</em> values altogether. Anyway, I can&rsquo;t help my bad gut feeling
whenever I see it ;)</p>

<p>The funny thing is that I recently wrote similar code myself; that
alone would not be a surprise yet, but I actually wrote it in
Haskell which does not have that notion of <em>null</em> values and the
corresponding Nullpointer exception. In Haskell, there is the <a href="https://www.haskell.org/haskellwiki/Maybe" target="_blank">Maybe monad</a> which facilitates chaining &ldquo;partial&rdquo; computations together without
the risk of a Nullpointer exception. Here is the snippet of that code
(obviously, only the <code>else Nothing</code> is &lsquo;important&rsquo;).</p>

<p><code>haskell
newState =
  if not shouldBeCompiled &amp;&amp; w' == view T.word W.immediate' then
   (oldState ^. lastColonDefinition ) &gt;&gt;=
   (\x -&gt; return $ oldState &amp; definedWords %~ (ix x %~ set isImmediate True))
  else
   Nothing
</code></p>

<p>Anyway, believe me, if you ever write such an <code>else Nothing</code> in Haskell, that should
be the trigger &ndash; take a deep breath, take a coffee and think about your
problem again. At the least, you are overcomplicating things as using
the <em>Monad</em> or <em>MonadPlus</em> nature of <em>Maybe</em> would make life easier
but probably it&rsquo;s an indication that your thoughts are about to go
astray and you get lost in old <code>else return null</code> habits or worse &ndash; so better
stop it and take a break!</p>

<p>How would the <em>MonadPlus</em> and <em>Monad</em> instances make life better? Look
at the below version. In any case, it&rsquo;s functionally equivalent, so
how would it be &lsquo;better&rsquo;? In my opinion, it conveys much
more the impression that the programmer actually knows what they are doing.</p>

<p>``` haskell
newState = do
  guard $ not shouldBeCompiled &amp;&amp; w' == (view T.word W.immediate')</p>

<p>  x &lt;&ndash; oldState ^. lastColonDefinition
  return $ oldState &amp; definedWords %~ (ix x %~ set isImmediate True)
```</p>

<p>Essentially, the <code>guard</code> function does the trick. <code>guard</code>, which has the type
<em>guard :: MonadPlus m => Bool &ndash;> m ()</em>, makes the containing <em>do</em>
block evaluate to <code>Nothing</code> if the <code>Bool</code> argument evaluates to
<code>False</code>. In that sense, the <code>guard</code> expression actually looks like an
assertion! The whole <em>MonadPlus</em> magic can be further explored <a href="http://en.wikibooks.org/wiki/Haskell/MonadPlus" target="_blank">here</a>.</p>

<p>In my case, I finally ended up removing those lines altogether. As suspected, the
good old <code>else Nothing</code> was the symptom that I had lost track of
what I was coding at all &ndash; completely lost in nothingness &ndash; and I really needed a
break.</p>

<p>So what is your typical &lsquo;silly code&rsquo; that you typically start writing when
you should rather take a break?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The notoriously point-free "((x.).)" trick]]></title>
    <link href="http://sleepomeno.github.io/blog/2014/08/14/Composing-two-argument-functions/"/>
    <updated>2014-08-14T00:00:00+02:00</updated>
    <id>http://sleepomeno.github.io/blog/2014/08/14/Composing-two-argument-functions</id>
    <content type="html"><![CDATA[<p><a href="http://www.haskell.org/haskellwiki/Pointfree" target="_blank">Point-free</a> code is ubiquitous in every well-polished Hackage library.
It&rsquo;s more concise than its pointed counterparts and feels more
&ldquo;hygienic&rdquo; as function composition immediately translates to its
mathematical background.</p>

<p><code>haskell
let pointFree = (+1) . read
let notPointFree x = (+1) (read x)
-- notPointFree 'mentions' its argument "x"
</code></p>

<p>So far, so good. However, you get a problem in your chain of function
composition when your right-most function &ldquo;takes two parameters&rdquo;.</p>

<p>``` haskell
let plusOne = (+1) :: Int &ndash;> Int
let readTwoArgs = (\x y &ndash;> read x + read y) :: String &ndash;> String &ndash;> Int</p>

<p>let coolSolution = plusOne . readTwoArgs :: String &ndash;> String &ndash;> Int
&mdash; Type checker doesn&rsquo;t like coolSolution</p>

<p>let boringSolution x y = plusOne (readTwoArgs x y)
&mdash; it&rsquo;s boring since it&rsquo;s not point-free
```</p>

<p>Unfortunately, <code>coolSolution</code> is not well-typed; this might drive you
nuts for some time: It&rsquo;s obvious that composing those functions must
somehow work. You&rsquo;d think: &ldquo;Even GHCI must have understood what I
mean!&rdquo; However, Haskell doesn&rsquo;t care for what you mean as much as it
cares for type-safety ;) ! So you might fall back on <code>boringSolution</code>
which is only half the fun as it&rsquo;s not point-free&#x2026; anyway, there IS
a way to compose those functions!</p>

<!-- more -->


<p>In the following I will use
<a href="http://www.haskell.org/haskellwiki/GHC/TypedHoles" target="_blank">Typed holes</a>. They are a nice tool to look into the type checker&rsquo;s
&ldquo;thoughts&rdquo;.
Well, first have a look at why <code>coolSolution</code> did not type-check at all.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>Couldn't match type ‘Int’ with ‘String -&gt; Int’
</span><span class='line'>Expected type: Int -&gt; String -&gt; Int
</span><span class='line'>  Actual type: Int -&gt; Int
</span><span class='line'>In the first argument of ‘(.)’, namely ‘plusOne’
</span><span class='line'>In the expression: plusOne . readTwoArgs :: String -&gt; String -&gt; Int
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Essentially, this tells us that <code>plusOne</code> does not have the right type
to be used together with <code>(. readTwoArgs)</code>. Now let&rsquo;s ask this
question to the type checker: What do I need to apply to <code>plusOne</code> so
that you are happy?</p>

<p><code>haskell
((_ plusOne) . readTwoArgs) "3" "2" :: Int
</code></p>

<p>The answer we get is:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>Found hole ‘_’
</span><span class='line'>  with type: (Int -&gt; Int) -&gt; (String -&gt; Int) -&gt; [Char] -&gt; Int
</span><span class='line'>Relevant bindings include it :: Int (bound at &lt;interactive&gt;:88:1)
</span><span class='line'>In the expression: _
</span><span class='line'>In the first argument of ‘(.)’, namely ‘(_ plusOne)’
</span><span class='line'>In the expression: (_ plusOne) . readTwoArgs
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Okay, this help us. Our &ldquo;hole function&rdquo;&rsquo;s type is <code>(Int -&gt; Int) -&gt;
(String -&gt; Int) -&gt; [Char] -&gt; Int</code>. Now we just write that
function &ndash; actually, the type signature and our knowledge of what
should be the result of the whole expression give rise to that <em>unique</em> <code>holeFunction</code>:</p>

<p><code>haskell
let holeFunction plusOne' stringToInt string = plusOne' (stringToInt string)
let holeFunction plusOne' stringToInt string = plusOne' . stringToInt $ string
let holeFunction plusOne' stringToInt = plusOne' . stringToInt
let holeFunction plusOne' stringToInt = (.) plusOne' stringToInt
let holeFunction plusOne' = (.) plusOne'
let holeFunction = (.)
</code></p>

<p>By (re)writing it in a point-free style and by applying eta-reductions we
get a very simple definition. It turns out that our <code>holeFunction</code> is
just ordinary function composition^^. Anyway, let&rsquo;s have a look if that works.</p>

<p><code>haskell
let coolSolution = ((.) plusOne). readTwoArgs
let coolSolution = (plusOne .). readTwoArgs
-- (coolSolution "3" "4") == 8
</code></p>

<p>Yes, it does! That &ldquo;.).&rdquo; looks funny and will surely confuse everybody
whose doesn&rsquo;t know that &ldquo;trick&rdquo; (and does not have a type-checker in
their brain). However, it gets even funnier. When your right-most
function expects even more arguments you just add &lsquo;a couple of&rsquo; &ldquo;.)"s
in between!</p>

<p><code>haskell
let wasteFourArgs = (\a b c d -&gt; read a + read b) :: String -&gt; String -&gt; String -&gt; String -&gt; Int
let coolSolution' = (((plusOne .) .) .). wasteFourArgs
</code></p>

<h2>Conclusion</h2>

<p>Thus, we have found a way to use the (point-free) function
composition even when you need to feed more than a single argument
into it!</p>

<p>As point-free code is more concise it can be clearer about what you
want to do, however, it can obfuscate your intentions as well! (Look
at those <a href="http://www.haskell.org/haskellwiki/Pointfree#Combinator_discoveries" target="_blank">combinators</a>). In the
case of this <em>((x.).)</em> trick, I think it can still be beneficial if
and only if everybody in your team &ldquo;knows the trick&rdquo; and does not have
to think about it. The nice reason is: As soon as you delete that &ldquo;.)&rdquo;
chain mentally you immediately grasp the meaning of the resulting function!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Explaining the Magic]]></title>
    <link href="http://sleepomeno.github.io/blog/2014/06/25/Explaining-the-Magic/"/>
    <updated>2014-06-25T00:00:00+02:00</updated>
    <id>http://sleepomeno.github.io/blog/2014/06/25/Explaining-the-Magic</id>
    <content type="html"><![CDATA[<p>Yesterday I came across a <a href="http://www.reddit.com/r/haskell/comments/28zx87/whats_your_favorite_response_to_the_show_me_the/" target="_blank">post</a> on the haskell reddit where somebody
posted the following application of <em>replicateM</em>:</p>

<p><code>haskell
:m +Control.Monad
replicateM 3 "01"
-- ["000","001","010","011","100","101","110","111"]
</code></p>

<h2>Dark Magic</h2>

<p>It obviously results in all three-character combinations of zeros and
ones and in general, <em>replicateM x &ldquo;01&rdquo;</em> generates all x-character
combinations of zeros and ones accordingly.</p>

<p><em>replicateM</em> is a standard library function and its haddock
documentation says: &ldquo;<em>replicateM n act</em> performs the action n times,
gathering the results&rdquo; and its type actually is <code>replicateM :: Monad m
=&gt; Int -&gt; m a -&gt; m [a]</code>. So <em>replicateM</em> is <strong>not</strong> a function
explicitly crafted for the purpose of a &ldquo;get me all x-ary combinations
of my string&rdquo; task, it is actually defined for all monads. Just
imagine a more obvious application using the IO monad, which <em>performs the action of
printing hello 3 times and gathers the result</em>.</p>

<p><code>haskell
replicateM 3 (putStrLn "hello")
-- hello
-- hello
-- hello
-- [(),(),()]
</code></p>

<p>It is typical Haskell practice to use a function with such a <em>general</em> look
to solve a rather <em>special</em> problem as our original one &ndash; to such a
degree that it seems like <strong>magic</strong> to programmers with a different
background. Actually, it might look like &ldquo;dark&rdquo; magic when you don&rsquo;t
grasp how/why the hell that result comes about in spite of looking at
the source of <em>replicateM</em>, and you might start getting annoyed with
Haskell altogether if that happens several times&#x2026; anyway, there is no
such thing as (dark) magic ;) so let&rsquo;s demystify that interesting example!</p>

<!-- more -->


<h2>Why it works</h2>

<p>Before looking at the source &ndash; and getting to the operational side of
<em>replicateM</em> &ndash; let&rsquo;s ask ourselves <em>why</em> we get that result.</p>

<p>By taking the documentation into account we can paraphrase <em>replicateM 3 &ldquo;01&rdquo;</em> by saying:
<em>It performs &ldquo;01&rdquo; 3 times and gathers the results</em>. But what sort of action is <code>&ldquo;01&rdquo;</code>.
As a string is a list of characters, it&rsquo;s equal to <code>[&lsquo;0&rsquo;,&lsquo;1&rsquo;]</code> which denotes a &lsquo;non-deterministic&rsquo; character value.
Imagine it as a two-faced character which doesn&rsquo;t know if it really is a &lsquo;0&rsquo; or a &lsquo;1&rsquo;! So what does <em>performing &ldquo;01&rdquo;</em> really mean?
I picture it as creating two parallel universes where that value dissolves into &lsquo;0&rsquo; in the first and into &lsquo;1&rsquo; in the second universe.
Performing another &ldquo;01&rdquo; branches those two universes again so that we get 4 universes. Doing that a third time, those 4
universes branch again in choosing the third value of either &lsquo;0&rsquo; or &lsquo;1&rsquo;. As a result, we get 8 universes which really are 8 lists of characters.
When you gather them you obviously get <em>[&ldquo;000&rdquo;,&ldquo;001&rdquo;,&ldquo;010&rdquo;,&ldquo;011&rdquo;,&ldquo;100&rdquo;,&ldquo;101&rdquo;,&ldquo;110&rdquo;,&ldquo;111&rdquo;]</em>! Confused? Maybe you like the &lsquo;How&rsquo; better!</p>

<h2>How it works</h2>

<p><a href="http://www.haskell.org/hoogle/" target="_blank">Hoogle</a> is my tool of choice to quickly get to base library haskell
source. So <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#replicateM" target="_blank">this</a> tells how <em>replicateM</em> is defined:</p>

<p><code>haskell
replicateM n x = sequence (replicate n x)
:t replicateM
-- replicateM :: Monad m =&gt; Int -&gt; m a -&gt; m [a]
</code></p>

<p>By hoogling for <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/src/GHC-List.html#replicate" target="_blank">replicate</a> and <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#sequence" target="_blank">sequence</a> we get the whole picture:</p>

<p>``` haskell</p>

<p>sequence ms = let k m m' = do { x &lt;&ndash; m; xs &lt;&ndash; m'; return (x:xs) } in foldr k (return []) ms
replicate n x           =  take n (repeat x)</p>

<p>:t sequence     <br/>
&mdash;sequence :: Monad m => [m a] &ndash;> m [a]
:t replicate
&mdash;replicate :: Int &ndash;> a &ndash;> [a]
```</p>

<p><em>replicate</em> surely is the easiest function to grasp: <code>replicate n x</code>
results in a list with <em>n</em> elements of value <em>x</em>. For instance:</p>

<p><code>haskell
replicate 3 "01"
--["01","01","01"]
</code></p>

<p>So we can actually get the following equations:</p>

<p><code>haskell
replicateM 3 "01" == sequence ["01","01","01"] ==
["000","001","010","011","100","101","110","111"]
</code></p>

<p>So the magic somehow lies in the <em>sequence</em> method or rather in the
List monad!</p>

<h3>Sequence</h3>

<p>As in our application <em>sequence</em> operates in the list monad you can
picture it using a list comprehension if you are more familiar with it:</p>

<p><code>haskell
sequence ms = let k m m' = [x:xs | x &lt;- m, xs &lt;- m'] in foldr k (return []) ms
-- m is a string, x is a character
-- m' is a list of strings (= the accumulator), xs is a string
:t sequence
-- sequence :: [[a]] -&gt; [[a]]
</code></p>

<p>Let&rsquo;s have a closer look at the last call of <em>k</em> in <em>sequence</em>.</p>

<p><code>haskell
replicateM 3 "01"
-- == k "01" ["00","01","10","11"] ==
[x:xs | x &lt;- "01", xs &lt;- ["00","01","10","11"]]
-- == ["000","001","010","011"] ++ ["100","101","110","111"]
-- == ["000","001","010","011","100","101","110","111"]
</code></p>

<p>At first <em>x</em> is selected to be &lsquo;0&rsquo; and prepended to all strings of
<em>xs</em>, the resulting list of strings is then concatenated with <em>x</em>
being &lsquo;1&rsquo; prepended to all strings of <em>xs</em> again. As a result, we will
always get a lexicographically correct ordering of all <em>n</em>-ary combinations of
&ldquo;01&rdquo; no matter what <em>n</em> we choose in <strong>replicateM n [&lsquo;0&rsquo;,&lsquo;1&rsquo;]</strong>.</p>

<p>We have seen how an innocent-looking function like <em>replicateM</em> can &ndash;
when it is used with the List monad &ndash; produce a &ldquo;magical&rdquo; result, only to then discover that there is no magic involved ;)</p>
]]></content>
  </entry>
  
</feed>
